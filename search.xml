<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[浏览器使用 VS Code 环境访问 github 项目]]></title>
    <url>%2F2021%2F03%2F25%2F%E6%B5%8F%E8%A7%88%E5%99%A8%E4%BD%BF%E7%94%A8-VS-Code-%E7%8E%AF%E5%A2%83%E8%AE%BF%E9%97%AE-github-%E9%A1%B9%E7%9B%AE%2F</url>
    <content type="text"><![CDATA[只要在 GitHub 仓库域名后面加上1s，比如github1s.com/facebook/react，就能在浏览器里面使用 VS Code 环境，浏览这个仓库的代码。网页链接]]></content>
      <categories>
        <category>it</category>
      </categories>
      <tags>
        <tag>小技巧</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[redis]]></title>
    <url>%2F2019%2F12%2F05%2Fredis%2F</url>
    <content type="text"><![CDATA[redisredis 特点 redis 支持数据的持久化，可以将内存中的数据保存在磁盘中，重启的时候可以再次加载进行使用。 热地说不仅仅支持简单的 key-value 类型的数据，同时还提供list，set，zset，hash等数据结构的存储。 redis支持数据库的备份，集群等高可用功能。 性能极高 读的速度1100000次/s，写的速度 81000次/s 支持publish/subscribe，通知，key过期。 定时器、计数器 安装修改配置文件等杂项 官网 https://redis.io 123456789101112131415161718# installwget http://download.redis.io/releases/redis-5.0.7.tar.gztar xzf redis-5.0.7.tar.gzcd redis-5.0.7make# 启动 服务端src/redis-server [../redis.conf]# 启动 客户端src/redis-cli# 命令目录/usr/local/bin/# 修改配置文件daemonize yes # 后台启动# 查看使用的配置文件redis-cli info | grep config # 查看redis备份文件的目录 可以在配置文件中修改config get dir 单进程： 单进程模式来处理客户端的请求，对读写等事件的响应是通过对epoll函数的包装来做到的，redis的实际处理速度完全依靠主进程的执行效率。 默认 16 个数据库,使用 select 1 可以切换数据库到第二个。 flushdb:清除当前库，flushall：清空所有库 索引都是从0开始 默认端口 6479 五大数据类型 string,hash,list,set,zset redis 命令大全 http://redisdoc.com/ 常用命令123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475########## keykeys * #查看所有 键exists keyname # 查看某个key是否存在move keyname db #移动某个key 到另一个数据库expire keyname 秒钟 #设置过期时间ttl key #查看key还有多少秒过期，-1表示永不过期，-2表示过期type keyname #查看key是什么类型########## stringset key value # 设置某值get key # 获取某值del key #删除append key 123 # 在值后面添加123strlen key # 获取字符长度incr key # 某值加1incrby key 2 # 某值加2decr key # 某值减去1decyby key 2 # 某值减去2getrange key 0 -1 # 获取某值的下标间的内容setrange key 0 xxx # 从某值的某个下标开始替换setex key 秒 value # 设置某值和过期时间setnx key value # 如果不存在才设置mset k1 v1 k2 v2 #同时设置多个值mget k1 k2 k3 #同时获取多个值msetnx k1 v1 k2 v2 #如果不存在同时设置多个值######### list 栈lpush key v1 v2 #从头部插入rpush key v1 v2 #从尾部插入lrange key 0 -1 #从头部依次取出数据lpop key #从头部取出一个数据rpop key # 从尾部取出一个数据lindex key 1 # 获取list 第1个元素llen key # 获取list的长度lrem key n v # 删除n个值ltrim key 0 4 #将0到4的范围取出来赋值给keyrpoplpush list1 list2 #从list1中获取最后一个放到list2中第一个位置上lset key index value #将 index 位置上的值替换为valuelinsert key before/after v1 v2 #在v1前插入v2################ 集合 setsadd set1 1 2 3 #向集合中加入元素smembers set1 #获取集合中的元素sismember set1 1 #判断 1是否是集合中的元素scard set1 #获取集合中的元素个数srem set1 1 #删除集合中的1srandmember set1 3 #随机取出3个数字spop set1 #随机取出一个值smove set1 set2 1 #将set1中的1移到set2中sdiff set1 set2 #获取在第一个集合里面而不在后面集合中的元素sinter set1 set2 #获取在第一个集合里面也在后面集合中的元素sunion set1 set2 #获取在第一个集合里面和后面集合中的所有元素的并集################## hashhset user id 11 # 设置 user 的 id 为11hget user id # 获取 user 的id属性hmset user id 11 name ss # 同时设置多个属性hmget user id name # 同时获取多个属性hgetall user # 获取所有属性和值hdel user name #删除某个键hlen user #获取user的属性个数hexists user name #判断user中是否有属性namehkeys user # 获取user中所有键hvals user # 获取user中所有值hincrby user id 2 #增加user中id的值 加2hincrbyfloat user score 0.5 #增加user中id的值 加0.5hsetnx user age 11 # 如何user中不存在user，设置值################### zset 有序集合zadd s1 60 v1 70 v2 #向集合s1中添加v1，v2。score分别为60和70zrange s1 0 -1 [withscores]#获取集合中所有值(按score排序)[score也显示出来]zrangebyscore s1 1 2 [limit 1 2]# 获取集合中score范围在1和2之间的[下标 在1和2之间的]zrem s1 v2 #删除集合下的某个元素zcard s1 #获取集合中元素的个数zcount s1 60 79 #获取集合在分数为60到79间的元素个数zrank s1 v1 #获取集合中v1的下标zscore s1 v1 #获取集合中v1的scorezrevrank s1 v1 #获取逆序的下标zrevrange s1 0 -1 #获取集合中所有值（按score反向排序）zrevrangebyscore s1 2 1 #获取集合中score范围在2和1之间的 redis 配置文件1234567891011121314tcp-backlog: backlog是一个连接队列，backlog队列总和=未完成三次握手队列 + 已完成三次握手队列 在高并发情况下需要一个高backlog的值来避免慢客户端连接问题timeout 客户端空闲多少秒后关闭连接loglevel 日志级别logfile 日志名字dir ./ 指定本地数据库存放路径maxclients 最大连接数maxMemory 最大内存限制 （0表示不限制）maxmemory-policy 超过最大内存限制后的策略有以下选项 volatile-lru:从已设置过期时间的内存数据集中挑选最近最少使用的数据 淘汰； volatile-ttl: 从已设置过期时间的内存数据集中挑选即将过期的数据 淘汰； volatile-random:从已设置过期时间的内存数据集中任意挑选数据 淘汰； allkeys-lru:从内存数据集中挑选最近最少使用的数据 淘汰； allkeys-random:从数据集中任意挑选数据 淘汰； no-enviction(驱逐)：禁止驱逐数据。（默认淘汰策略。当redis内存数据达到maxmemory，在该策略下，直接返回OOM错误）； redis 持久化 rdb(redis database),AOF(append only file) RDB RDB 是指在指定时间间隔内将内存中的数据集快照写入磁盘，恢复时是将快照文件直接读到内存中 redis在进行数据持久化的过程中，会先将数据写入到一个临时文件中，待持久化过程都结束了，才会用这个临时文件替换上次持久化好的文件。正是这种特性，让我们可以随时来进行备份，因为快照文件总是完整可用的。 对于RDB方式，redis会单独创建（fork）一个子进程来进行持久化，而主进程是不会进行任何IO操作的，这样就确保了redis极高的性能。 如果需要进行大规模数据的恢复，且对于数据恢复的完整性不是非常敏感，那RDB方式要比AOF方式更加的高效。 虽然RDB有不少优点，但它的缺点也是不容忽视的。如果你对数据的完整性非常敏感，那么RDB方式就不太适合你，因为即使你每5分钟都持久化一次，当redis故障时，仍然会有近5分钟的数据丢失。所以，redis还提供了另一种持久化方式，那就是AOF。 12345678#默认配置save 60 10000 #1分钟内改了1万次就备份save 300 10 #5分钟内改了10次就备份save 900 1 #15分钟内改了一次就备份#启动时或默认加载启动目录的dump.rdb文件进行数据导入save 运行save命令会直接备份，此时不能向数据库存储bgsave 后台异步备份，可以同时存储数据 AOF AOF，英文是Append Only File，即只允许追加不允许改写的文件。 如前面介绍的，AOF方式是将执行过的写指令记录下来，在数据恢复时按照从前到后的顺序再将指令都执行一遍，就这么简单。 12345678910111213141516171819202122#配置文件开启 aof# 开启后默认加载启动目录的 appendonly.aof 文件进行数据倒入# 如果同时存在dump.rdb和appendonly.aof，redis开启时默认使用appendonly.aof启动服务器appendonly yes# 配置文件 appendsync 同步方式appendsync aways 每次数据变化都记录一次 everysec 每秒记录一次 no# aof文件会越来越大 所以会有重写的过程# 重写条件：默认配置是当aof文件大小是上次rewrite后大小的一倍且文件大于64M时触发# no-appendfsync-on-rewrite 重写时是否可以运用appendfsync,用默认no即可，保证数据安全Auto-aof-rewrite-min-size 64auto-aof-rewrite-pecentage 100#如果aof文件损坏导致无法启动redis，可以使用以下命令修复aof文件redis-check-aof --fix appendonly.aof redis事务 可以一次执行多个命令，本质是一组命令的集合，一个任务的所有命令都会序列化，按顺序地串行化执行，而不会被其他命令插入，不许加塞。 123456789101112131415161718192021222324252627282930313233343536371. 正常执行multi #开启事务set k1 v1set k2 v2exec #执行事务2. 放弃事务multi #开启事务set k1 v1set k2 v2discard #放弃事务3. 全体连坐multi #开启事务set k1 v1sett k2 v2exec #执行事务#直接报错4. 冤头债主multi #开启事务set k1 aaincr k1set k1 v1sett k2 v2exec #执行事务#只有 incr 报错（incr 是字符串不能加1）5. watch 监控set balance 100set debt 0watch balance #监控balancemulti # 开启事务decrby balance 20incrby debt 20exec # 结束事务# 监控某个值后，如果这个值在另一个客户端发生变化会导致本次事务提交失败此时执行 unwatch 可以取消监控，再执行watch重新监控。 redis订阅123subscribe c1 c2 c3* #订阅3个频道，支持通配符publish c2 hello # 发布消息 redis主从复制123456#要启用主从复制必须取消bind的验证,此时可以分别在主机和从机设置requirepass 和masterauth 来增加密码验证info replication # 查看主从复制的信息#开启从机， 在从机中执行,从机下也可以有从机slaveof 主机ip 主机端口#从机 会复制主机的所有数据 原理slave 启动成功连接到master后发送一个sync命令，master记到命令后启动后台的存盘进程，同时收集所有接收到的用于修改数据的命令，在后台进程执行完毕之后，master将传送整个数据文件到slave，以完成同步。 哨兵模式https://juejin.im/post/5b7d226a6fb9a01a1e01ff64]]></content>
      <categories>
        <category>it</category>
      </categories>
      <tags>
        <tag>redis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mysql 高级]]></title>
    <url>%2F2019%2F09%2F27%2Fmysql-%E9%AB%98%E7%BA%A7%2F</url>
    <content type="text"><![CDATA[mysql配置文件 ps -ef|grep mysql 查看datadir，show variables like &#39;character%&#39;查看编码，mysqld --help --verbose|more 查看配置文件位置，修改配置文件的编码为utf8。 二进制日志log-bin，主要负责主从复制 错误日志log-error，默认是关闭的，记录严重的警告和错误信息 查询日志log，默认是关闭的，记录查询sql的语句，如果开启会降低mysql性能 数据文件：frm文件存放表结构，myd文件存放表数据，myi文件存放表索引，ibd是数据索引文件 mysql 存储引擎12show engines;# 查看存储引擎SHOW VARIABLES LIKE &apos;%storage_engine%&apos;; # 当前存储引擎 对比项 MyISAM InnoDB 主外键 不支持 支持 事务 不支持 支持 行表锁 表锁，即使操作一条记录也会锁住整个表，不适合高并发 行锁 缓存 只缓存索引，不缓存真实数据 不仅缓存索引还要缓存真实数据，对内存要求高，内存大小对性能有影响 表空间 小 大 关注点 性能 事务 mysql sql性能下降原因 查询语句写的烂 索引失效 关联查询太多join 服务器调优各个参数设置（缓冲、线程数等） mysql 机器执行加载顺序from==on==join==where==group by==having==select==order by==limit 索引 索引是帮助 mysql 高效获取数据的数据结构。你可以简单理解为”排好序的快速查找数据结构” 在数据之外，数据库系统还维护着满足特定查找算法的数据结构，这些数据结构以某种方式指向数据，这样就可以在这些数据结构上实现高级查找算法。这些数据结构就是索引。索引本身也很大需要存放到磁盘上 优势 类似大学图书馆建书目索引，提高数据检索效率，降低io成本。 通过索引列对数据进行排序，降低数据排序的成本，降低cpu消耗。 劣势 索引也是一张表，该表保存了主键与索引字段，是要占用空间的。 提高查询效率的同时，降低了修改效率。 索引分类 单值索引 唯一索引 复合索引 索引结构 BTree索引（不是二叉树，可以有多个叉） Hash索引 full-text全文索引 R-Tree索引 那些情况适合建索引 主键自动建立索引 频繁查询的字段 在高并发下倾向创建组合索引 查询中排序的字段，排序的字段若通过索引去访问将大大提高排序速度 那些情况不适合建索引 表记录太少 经常增删改的表 数据很多重复的字段 mysql 常见瓶颈 cpu: 在饱和的时候一般发生在数据装入内存或从磁盘上读取数据的时候 IO: 磁盘IO瓶颈发生在装入数据远大于内存容量的时候 服务器硬件性能瓶颈：top,free,iostat和vmstat来查看系统性能状态 explain explain 可以模拟优化器执行sql查询语句，从而知道mysql是如何处理你的sql语句的，分析你的查询语句或是表结构的性能瓶颈,使用:explain + sql id select_type table partitions type possible_keys key key_len ref rows filtered Extra 1 SIMPLE account NULL ALL NULL NULL NULL NULL 2 100.00 NULL id: select 查询的序列号，包含一组数字，表示查询中执行select子句或操作表的顺序 id 相同时执行顺序从上到下。 如果是子查询，id的值越大，优先级越高，越先执行。 id 相同和不同同时存在，id相同的算一组，从上往下顺序执行；在所有组中，id越大，越先执行。 DERIVED 表示衍生的表。 select_type 查询类型：包括SIMPLE|PRIMARY|SUBQUERY|DERIVED|UNION|UNION RESULT SIMPLE 简单的select查询，查询中不包括子查询或union PRIMARY 主查询 SUBQUERY 子查询 DERIVED 子查询产生的衍生表 UNION 联合查询 UNION RESULT 从UNION表获取结果的select type 访问类型：包括 ALL|index|range|ref|eq_ref|const,system|null。从最好到最差依次是 system&gt;const&gt;eq_ref&gt;ref&gt;range&gt;index&gt;ALL 。详细来说的话system&gt;const&gt;eq_ref&gt;fulltext&gt;ref_or_null&gt;index_merge&gt;unique_subquery&gt;index_subquery&gt;range&gt;index&gt;ALL。一般来说，得保证查询至少达到range级别，最好能达到ref。 system：表只有一行记录（等于系统表），这是const类型的特例 const：表示通过索引一次就找到了，const用于比较primary key或者unique索引。 eq_ref: 唯一性索引扫描，对于每个索引键，表中只有一条记录与之匹配。常见于主键或唯一索引扫描。 ref：非唯一性索引扫描，返回匹配某个值的所有行。 range 只检索给定范围的行，使用一个索引来选择行，key列显示使用的索引。 例子：select * from table where id between 1 and 40; index index只遍历索引树，这通常比ALL快，因为索引文件通常比数据文件小。（也就是说虽然all和index都是读全表，但index是从索引中读取的，而all是从硬盘读取的）例子：select id from table;只获取索引字段。 all 全表扫描 possible_keys 可能用到的索引；key 真实用到的索引 key_len 表示索引中使用的字节数。key_len显示的值为索引字段的最大可能长度，并非实际使用长度。 ref 显示索引的哪一列被使用了，如果可能的话，最好是一个常数。哪些列或者常量被用于查找索引列上的值 根据表统计信息及索引选用情况，大致估算出找到所需的记录所需要读取的行数。 extra 包含不适合在其他列显示，但十分重要的信息。 Using filesort 说明mysql会对数据使用一个外部索引排序，而不是按照表内的索引顺序进行读取，会降低查询效率。 Using temporary 使用临时表保存中间结果，mysql在对查询结果排序时使用临时表。常见于排序order by和分组查询group by。会降低查询效率 Using index （覆盖索引：select的数据列只用从索引中就能够取得，不必读数据行，提高查询效率）表示从索引来查找数据，避免了访问表的数据行，效率不错 Using where 使用了where Using join buffer 使用了连接缓存 impossible where where结果的值为false 索引优化案例分析 单表分析 comments&gt;1时会出现Using filesort,所以需要更换索引 drop index idx_article_ccv on article 两表分析 索引如果加在右表 drop index Y from book;,索引如果加在左表 所以左连接时右表是关键点，一定要建立索引索引失效 全值匹配我最爱(复合索引的第一个索引必须使用，而且要按顺序往下使用,不能跳过索引列,否则会导致索引失效，复合索引在范围条件之后全失效) 在索引列上做任何操作（计算，函数，（自动or手动）类型转换），会导致索引失效。 存储引擎不能使用 联合索引中范围条件右边的列。 尽量使用覆盖索引，减少select * 的使用。 使用 不等于（!= &lt;&gt;),is null,is not null会导致索引失效。 左边写 %的like 会导致索引失效；如果非要在左边加%，则尽量使用覆盖索引，避免使用select *。 字符串类型 不加单引号会导致索引失效。 少用 or，用它来连接会导致索引失效。分析 观察，至少跑一天，看看产生的慢sql情况。 开启慢查询日志，设置阀值，比如超过5秒就是慢sql，将它抓取出来。 explain+慢sql分析 show profile 运维经理 or DBA，进行sql数据库服务器的参数调优。mysql: in,exist优化优化原则：小表驱动大表select from a where id in (select id from b)当b表数据集小于a表时用 in 优于 existsselect from a where exists (select 1 from b where b.id=a.id)当b表数据集大于a表时用 exists 优于 inorder by 关键字优化 尽量使用 index 方式排序，避免使用 filesort 方式排序 尽可能在索引列上完成排序操作，遵照索引的最佳左前缀 如果不在索引列上 filesort 有两种算法，mysql就要启动双路排序和单路排序。单路排序总体来说优于双路，但是单路排序所使用的buffer更多。优化策略：增大sort_buffer_size参数设置，增大max_length_for_sort_data参数的设置慢查询日志默认mysql数据库没有开启慢查询日志，需要手动设置这个参数。 查看是否开启show variables like &#39;%slow_query_log%&#39;。 开启慢查询日志set global slow_query_log=1只对当前数据库生效，重启后失效。如果要永久生效，修改my.cnf，[mysqld] 下增加或修改参数12slow_query_log=1slow_query_log_file=/var/lib/mysql/host-slow.log 重启后生效。 查看慢查询日志的时间 show variables like &#39;long_query_time%&#39; 设置慢查询日志时间 set global long_query_time=3,设置以后要重新开一个窗口才能生效查看慢查询的个数 show global status like &#39;Slow_queries&#39; 日志分析工具 mysqldumpslowmysqldumpslow –help profileprofile 是mysql提供可以用来分析当前会话中语句执行的资源消耗情况，可用于sql的调优测量 查看 profile 状态 show variables like &#39;profiling&#39;; 默认关闭 开启profile set profiling=on; 查看sql记录 show profiles; 诊断sql show profile cpu,block io for query 5;#5指show profiles的id号出现以下步骤：说明应该优化了 converting HEAP to MyISAM 查询结果太大了，内存不够用了往磁盘上搬了。 Creating tmp table 创建临时表：拷贝数据到临时表，用完再删除。 copying to tmp table on disk 把内存中临时表复制到磁盘，危险！！ locked 全局查询日志 （永远不要在生产环境上开启）12345## 开启 set global general_log=1;set global log_output=&apos;TABLE&apos;;## 此后，你所编写的所有sql语句都将记录到mysql库里的general_log表，可以用下面的命令查看select * from mysql.general_log; mysql 锁机制从数据的操作类型分类： 读锁(共享锁):针对同一份数据，多个读操作可以同时进行而不会相互影响。 写锁(排它锁):当前写操作没有完成前,他会阻断其他写锁和读锁。从对数据的操作粒度分类: 表锁。 行锁。 myisam 表锁案例讲解123456789101112131415161718192021# 建表 sqlcreate table mylock( id int not null primary key auto_increment, name varchar(20) )engine myisam; insert into mylock(name) values(&apos;a&apos;);insert into mylock(name) values(&apos;b&apos;);insert into mylock(name) values(&apos;c&apos;);insert into mylock(name) values(&apos;d&apos;);insert into mylock(name) values(&apos;e&apos;);select * from mylock;# 手动增加表锁lock table 表名字 read(write);# 查看 所有表 的锁状态show open tables;#释放表锁unlock tables; 增加读锁一个会话 增加表读锁以后只能读当前表，不能修改，不能读其他表。会话结束后自动解锁。其他窗口可以读当前表，修改的话会被阻塞直到表锁解开，可以操作其他表。 增加写锁一个会话 增加表写锁以后可以操作当前表，不能操作其他表。会话结束后自动解锁。其他窗口操作该表会阻塞直到表锁解开，可以操作其他表 总结：MyISAM 在执行查询语句（select）前，会自动给涉及的所有表增加读锁，在执行增删改操作前，会自动给涉及的表增加写锁。mysql表级锁有两种模式：表共享读锁，表独占写锁。简而言之，就是读锁会阻塞写，但是不会阻塞读。而写锁会把读和写都阻塞。1234# 查看表锁 状态show status like &apos;table%&apos;;# Table_locks_immediate 表示产生表级锁定的次数# Table_locks_waited 表示等待表锁的次数，如果此值很大，说明存在较严重的表级锁征用情况。 MyISAM 的读写锁调度是写优先，这也是 MyISAM 不适合做写为主表的引擎。因为写锁后，其他线程不能做任何操作，大量更新会使查询很难得到锁，从而造成永远阻塞。 innodb 行锁案例讲解 innodb 与 myisam 最大的区别在于 1.innodb支持事务2.采用行锁 12345678910111213141516171819create table test_innodb_lock( a int(11), b varchar(16) )engine=innodb; insert into test_innodb_lock values(1,&apos;b2&apos;);insert into test_innodb_lock values(3,&apos;3&apos;);insert into test_innodb_lock values(4,&apos;4000&apos;);insert into test_innodb_lock values(5,&apos;5000&apos;);insert into test_innodb_lock values(6,&apos;6000&apos;);insert into test_innodb_lock values(7,&apos;7000&apos;);insert into test_innodb_lock values(8,&apos;8000&apos;);insert into test_innodb_lock values(9,&apos;9000&apos;);insert into test_innodb_lock values(1,&apos;b1&apos;);create index test_innodb_a_ind on test_innodb_lock(a);create index test_innodb_lock_b_ind on test_innodb_lock(b);select * from test_innodb_lock; innoDB存储引擎支持表锁和行锁。顾名思义，表锁是锁住整张表，行锁只是锁住某些行。InnoDB通过给索引项加锁来实现行锁，如果没有索引，则通过隐藏的聚簇索引来对记录加锁。如果操作不通过索引条件检索数据，InnoDB 则对表中的所有记录加锁，实际效果就和表锁一样。1234# 锁定某一行，其他操作会被阻塞直到 提交select * from test_innodb_lock where a=8 for update;# 查看 锁状态show status like &apos;innodb_row_lock%&apos;; 行锁总结 尽可能让所有数据检索都通过索引完成，避免无索引行锁升级为表锁。 合理设计索引，尽量缩小锁范围。 尽可能减少检索条件，避免间隙锁。 尽可能控制事务的大小，减少锁定资源量和时间长度 尽可能降低级别事务隔离 mysql 主从复制 基本原理: slave 会从 master 读取binlog来进行数据同步 mysql 复制过程分三步： master 将改变记录到二进制日志，这些记录过程叫做二进制日志事件，binary log events。 slave 将master的binary log events 拷贝到它的中继日志。 slave 重做中继日志中的事件，将改变应用到自己的数据库中, mysql 复制是异步串行化的mysql 复制基本规则 每个slave只有一个master。 每个slave只能有一个唯一的服务器id。 每个master可以有多个slave。 mysql 复制的最大问题：网络延时mysql 一主一从常见配置 主机ip 172.18.2.44 从机ip 172.18.3.251 mysql 版本一致且后台以服务运行 主从ip互相ping通。 主从配置在[mysqld]结点下,都是小写。 主机修改my.cnf 配置文件。 123456789101112131415161718#主数据库端ID号server_id = 1 #开启二进制日志 log-bin = mysql-bin #需要复制的数据库名，如果复制多个数据库，重复设置这个选项即可 binlog-do-db = db #将从服务器从主服务器收到的更新记入到从服务器自己的二进制日志文件中 log-slave-updates #控制binlog的写入频率。每执行多少次事务写入一次(这个参数性能消耗很大，但可减小MySQL崩溃造成的损失) sync_binlog = 1 #这个参数一般用在主主同步中，用来错开自增值, 防止键值冲突auto_increment_offset = 1 #这个参数一般用在主主同步中，用来错开自增值, 防止键值冲突auto_increment_increment = 1 #二进制日志自动删除的天数，默认值为0,表示“没有自动删除”，启动时和二进制日志循环时可能删除 expire_logs_days = 7 #将函数复制到slave log_bin_trust_function_creators = 1 主机添加从机登录的用户。 123456#添加 从机登录的用户grant replication slave on *.* to &apos;account&apos;@&apos;172.18.3.251&apos; identified by &apos;sUx5U0lYO@&apos;;# 更新权限flush privileges;# 查看主机状态show master status\G; 从机修改配置文件。 1234567891011server_id = 2log-bin = mysql-binlog-slave-updatessync_binlog = 0#log buffer将每秒一次地写入log file中，并且log file的flush(刷到磁盘)操作同时进行。该模式下在事务提交的时候，不会主动触发写入磁盘的操作innodb_flush_log_at_trx_commit = 0 #指定slave要复制哪个库replicate-do-db = db #MySQL主从复制的时候，当Master和Slave之间的网络中断，但是Master和Slave无法察觉的情况下（比如防火墙或者路由问题）。Slave会等待slave_net_timeout设置的秒数后，才能认为网络出现故障，然后才会重连并且追赶这段时间主库的数据slave-net-timeout = 60 log_bin_trust_function_creators = 1 从机开启服务。 12345678910# 设置主机信息change master to master_host=&apos;172.18.2.44&apos;,master_user=&apos;account&apos;,master_password=&apos;sUx5U0lYO@&apos;,master_log_file=&apos;mysql-bin.000002&apos;,master_log_pos=337523;/* 开启从机 启动I/O 线程和SQL线程。 I/O线程从主库读取bin log，并存储到relay log中继日志文件中。 SQL线程读取中继日志，解析后，在从库重放。*/start slave;# 查看状态show slave status\G;#Slave_IO_Running及Slave_SQL_Running 为yes表示正常启动]]></content>
      <categories>
        <category>it</category>
      </categories>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mysql 基础]]></title>
    <url>%2F2019%2F07%2F31%2Fmysql-%E5%9F%BA%E7%A1%80%2F</url>
    <content type="text"><![CDATA[mysql 语法规范 不区分大小写，但建议关键字大写，表名，列名小写。 分号结尾。 每条命令根据需要缩进，换行。 注释单行用 # 号，多行 / 注释 / mysql 常用命令123456use test #使用 test 数据库show tables #查看数据库中的所有表show tables form mysql #查看 mysql 数据库中的表select database() #查看当前在哪个数据库desc table #查看表的结构select version() #查看 mysql 版本 mysql 基础查询 语法： select 查询列表 from 表名 特点 查询列表可以是：表中的字段、常量值、表达式、函数。 查询的结果是一个虚拟的表格。12345678910111213141516171819202122232425262728293031# 1.查询列select * from table;select `name`,`age` from table;# 2.查询常量值select 100;select &apos;john&apos;;# 3.查询表达式select 100*90;# 4.查询函数select version();# 5.起别名select 100*90 as 结果;select name 姓名 from table;# 6.去重复select distinct name from table;# 7. 拼接 NULL 和任何数据链接都为 NULL 可以用函数 IFNULL(NULL,0)select concat(name,age) from table;select concat(name,IFNULL(age,0)) from table;# 8.查询 姓名第三个字符为e第五个字符为aselect * from users where name like &apos;__e_a%&apos;;# 9.查询 姓名第二个字符为_的员工名select * from users where name like &apos;_\_%&apos;;或者select * from users where name like &apos;_$_%&apos; ESCAPE &apos;$&apos;;# 10. 查询没有奖金的用户（null），有奖金的用户（not null）select * form users where bonus is NULL;(不能用=号)select * form users where bonus is not NULL;(不能用!=号)# 11. 按姓名长度排序select LENGTH(name) as l,name from users order by l;# 12. 先按工资排序，再按编号排序select * from user order by salary,id mysql 常见函数1.单行函数1234567891011121314151617181920212223242526272829# 1.length 获取参数字节个数select LENGTH(&apos;john&apos;);select LENGTH(&apos;张三丰&apos;); # 中文字节个数与字符集相关show variables like &apos;%char%&apos;; #查看字符集# 2.concat 拼接字符select CONCAT(&apos;name&apos;,&apos;age&apos;);# 3.upper 、 lowerselect UPPER(&apos;honf&apos;);select lower(&apos;JFD&apos;);#4.substr、substring# mysql 索引从 1 开始select SUBSTR(&apos;李莫愁爱上了陆展元&apos;,7) output # 陆展元select SUBSTR(&apos;李莫愁爱上了陆展元&apos;,1，3) output # 李莫愁#5. instr 返回子串第一次出现的索引，找不到返回0select instr(&apos;杨不悔爱上了殷六侠&apos;,&apos;殷六侠&apos;);#6. trim 截取字符串两边的符号select TRIM(&apos; 张翠山 &apos;);select TRIM(&apos;a&apos; from &apos;aaa张aaa翠山aaa&apos;);#7.lpad、rpad 用指定的字符实现左、右填充到指定长度select lpad(&apos;fd&apos;,&apos;10&apos;,&apos;*&apos;)#8. replace 替换select REPLACE(&apos;周芷若&apos;,&apos;周芷若&apos;,&apos;赵敏&apos;) as out_put; 2.数学函数1234567891011# 1.round 四舍五入select ROUND(-1.45)select ROUND(1.567,2) # 保留两位小数# 2. ceil 向上取整select CEIL(1.01)# 3.floor 向下取整select FLOOR(9.9)# 4.truncate 截断select TRUNCATE(1.6999,1);保留几位小数$ 5.mod 取余select MOD(10,3); 3.日期函数123456789101112131415# 1.now 返回当前系统日期 + 时间select NOW(); # 2019-07-18 11:12:34# 2. curdate 返回当前系统日期，不包含时间select CURDATE(); # 2019-07-18# 3. curtime 返回当前时间，不包含日期select CURTIME();# 11:12:34# 4.可以获取指定的部分， 年、月、日、小时、分钟、秒select YEAR(NOW());select MONTH(NOW());select MONTHNAME(NOW());#....# 5.str_to_date 将字符通过指定格式转换成日期SELECT STR_TO_DATE(&apos;1998-3-2&apos;,&apos;%Y-%m-%d&apos;);# 6.date_format 将日期转换成指定格式的字符select DATE_FORMAT(NOW(),&apos;%y年%m月%d日&apos;); 4.其他函数123select VERSION();select DATABASE();select USER(); 5.流程控制函数123456# 1.if函数select IF(10&gt;5,&apos;大&apos;,&apos;小&apos;);# 2.case 函数的使用一：switch case 的效果，等值判断select salary,id, case id when 1 then salary*2 when 2 then salary*3 else salary end as 新工资 from users;# 3.case 函数的使用二：条件判断select salary,case when salary&gt;20000 then &apos;A&apos; when salary&gt;10000 then &apos;B&apos; else &apos;D&apos; end as 工资级别 from users; 6.分组函数 sum,avg,max,min,count 1.简单使用12select sum(salary) from users;select sum(salary),avg(salary) from users; 2.参数支持哪些类型？ sum,avg 只支持数值型 max,min,count 支持任何类型 count,sum,avg,max,min 遇到 NULL 时不计数3.搭配 distinct1select SUM(distinct salary),SUM(salary),COUNT(DISTINCT salary) from users; 4.count 具体介绍123select COUNT(salary) from users;select COUNT(*) from users;select COUNT(1) from users; 5.分组查询123456789# 查询每个工种的最高工资select max(salary),job_id from users group BY job_id;# 分组后的查询# 查询哪个部门的员工个数&gt;2select count(*),department_id from users group BY department_id having count(*) &gt;2;# 查询每个工种有奖金的员工的最高工资&gt;12000的工种编号和最高工资select max(salary),job_id from users where commission_pct is not null group BY job_id having max(salary) &gt; 12000;# 按多个字段分组select avg(salary),department_id,job_id from `users` group by department_id,job_id; 6.连接查询1234567891011121314151617181920212223242526272829303132333435363738394041424344#连接按功能分类# 一. 内连接 查询表的交集部分 # 等值连接 # 非等值连接 # 自连接# 二. 外连接 查询主表所有记录 和 匹配的从表记录（未匹配显示null） # 左外连接 left join 左边是主表 # 右外连接 right join 右边是主表# 三. 交叉连接#### sql92 语法（只支持内连接）# beauty m行，boys n行# 从 beauty 和 boys 表中取出 name 和 boyName 会出现笛卡尔乘积 m*nselect name,boyName from beauty,boys;# 1.等值连接 加条件限制 select name,boyName from beauty,boys where beauty.id=boys.boyfriend_id; # 给表起别名 select name,boyName from beauty be,boys bo where be.id=bo.boyfriend_id; # 添加筛选条件 select name,boyName from beauty be,boys bo where be.id=bo.boyfriend_id and name like &apos;_o%&apos;; # 添加分组 select count(*),city from departments d,locations l where d.location_id = l.location_id group by city; # 支持多表连接# 2.非等值连接 select salary,grade_level from employees e,job_grades g where salary between g.lowest_sal and highest_sal;# 3.自连接 # 查询员工和上级的姓名 select e.employee_id,e.last_name,m.employee_id,m.last_name from employees e,employees m where e.manager_id=m.employee_id;# # # # sql99 语法# 内连接# 1.等值连接 inner 可以省略 select last_name,department_name from departments d inner join employees e on e.department_id = d.department_id; # 其他内连接类似# 2.外连接 # 查询 男朋友不在男神表中的女神名称 select b.name FROM beauty b left outer join boys bo on b.boyfriend_id=bo.id where id is NULL;# 3.交叉连接 # 就是笛卡尔乘积 select b.*,bo.* from beauty b cross join boys bo; 7.子查询 出现在其他语句中的 select 语句，称为子查询。例： select first name from employees where department_id in(select department_id from departments where location_id=1700); mysql 多行操作符，in,not in, any, some, all12345678910111213141516# 一、where 或 having 后面的子查询# 1.标量子查询 查询谁得工资比 abel 高 select * from employees where salary &gt; (select salary from employees where last_name = &apos;abel&apos;);# 2.列子查询 select last_name from employees where department_id in(select distinct department_id from departments where location_id in(1400,1700));# 3.行子查询 select * from employees where (employee_id,salary)=(select min(employee_id), max(salary) from employees);# 二、select 后面的子查询# 1. 查询每个部门的员工个数 select d.*,(select count(*) from employees e where e.department_id=d.department_id) from departments d; # 三、from 后面的子查询# 1.查询每个部门的平均工资等级 select ag_dep.*,g.grade_level from (select avg(salary) ag,department_id from employees group by department_id) ag_dep inner join job_grades g on ag_dep.ag between lowest_sal and highesh_sal;# 四、exists 后面（相关子查询）;select exists() 判断是否存在# 1. 查询有员工的部门名 select department_name from departments d where exists(select * from employees e where d.department_id=e.department_id); 8.分页查询12345# 查询前 5 条信息select * from employees limit 0,5;select * from employees limit 5;# 查询第 11 条到第 25 条select * from employees limit 10,15; 9.联合查询 只是多添加了一些数据,前后列必须一样。123select * from employees where email like &apos;%a%&apos;UNION select * from employees where department_id&gt;90; DML语言插入语句 insert into 表名(列名,…) values(值1,..); insert into 表名 values(值1,..); # 所有列，并且顺序和表一样 insert into 表名 set 列=值,列=值;修改语句 update 表名 set 列=值,列=值,… where 条件; update 表1 别名 inner|left|right join 表2 别名 on 连接条件 set 列=值,… where 条件;删除语句 delete from 表名 where 条件; truncate table 表名; DDL 数据定义语言库的管理12345678# 创建库create database books;# 不能存在则创建。create database if not exists books;# 更改字符集alter database books character set gbk;# 库的删除drop database if exists books; 表的管理123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141# 创建# create table 表名(# 列名 列的类型 [(长度) 约束],# 列名 列的类型 [(长度) 约束],# 列名 列的类型 [(长度) 约束],# )create table book ( id int, bName varchar(20), price double, authorId int, publishData datetime);# 修改## 修改列名alter table book change column publishdate pubDate datetime;## 修改类型约束alter table book modify column pubdate timestamp;## 添加列alter table author add column annual double;## 删除列alter table author drop column annual;## 修改表名alter table author rename to book_author;## 删除drop table book_author;# 表的复制## 复制表的结构create table copy like author;## 复制结构和数据create table copy2 select * from author;## 复制部分数据或部分列CREATE TABLE copy3 SELECT id,name FROM author WHERE id&gt;3;## 复制部分结构CREATE TABLE copy4 SELECT id,name FROM author where 0;# 表的类型和约束## 整型### tinyint(1字节)\smallint（2字节）\mediumint\int（4字节）\bigint（8字节）###1. 如果不设置无符号，默认为有符号###2. int后面有默认长度无需设置。如果设置长度必须搭配 zerofill，表示显示的最小宽度，此时 unsigned 无效create table tab_int ( t1 int, t2 int UNSIGNED, t3 int(6) ZEROFILL);## 小数### 浮点型 float\double （M,D）### 定点型 dec\decimalcreate table tab_float( f1 float(5,2), f2 double(5,2), f3 decimal(5,2));###1. 第一个参数表示总共几位数，第二个参数表示小数点后几位###2. 超过则显示临界值，decimal 默认 M=10,D=0 float,double 或根据插入数字自行计算。## 字符### char/varchar#### varchar 相对节省空间，但效率低一些。 char(M) M默认是1，varchar(M) M必须填。### enum 不区分大小写create table tab_char( c1 ENUM(&apos;A&apos;,&apos;B&apos;));### set 可以一次插入多个 不区分大小写create table tab_set( c1 set(&apos;A&apos;,&apos;B&apos;,&apos;C&apos;));## 日期### date\datetime\timestamp\time\year### timestamp 与 datetime 都显示日期时间，timestamp 字节数较小，受时区影响## 表的约束/* create table 表名 ( 字段名,字段类型,列级约束, 字段名,字段类型,列级约束, 表级约束)*/###1. not null###2. default###3. primary key 用于保证字段唯一性，并且非空###4. unique 用于保证字段唯一性，可以为空###5. foreign key 外键用于限制该字段的值必须来自于主表的关联列的值，在从表添加约束### 列级约束：除了5都支持create table stuinfo( id INT PRIMARY KEY, name VARCHAR(20) NOT NULL , gender CHAR(1), seat INT UNIQUE , age INT DEFAULT 18, majorId INT REFERENCES major(id) # 不生效);### 外键不生效### 表级约束：除了非空、默认，其他都支持create table stuinfo( id INT, name VARCHAR(20), gender INT, age INT, majorid INT, CONSTRAINT pk PRIMARY KEY(id), CONSTRAINT uq UNIQUE (seat), CONSTRAINT fk_stuinfo_major FOREIGN KEY (marjorid) REFERENCES major(id) #外键);### CONSTRAINT name 可以省略show index from stuinfo;#查看索引信息### 主键和唯一的区别### 保证唯一性 是否允许空 一个表中可以有多个 允许组合### 主键 是 否 否 是### 唯一 是 是 是 是/* 外键 1。在从表中设置外键 2。从表和主表 外键列类型要求一致或兼容，名称无要求 3。主表关联列必须是一个key（一般是主键或唯一） 4。插入数据时先插入主表，再插入从表；删除时先删除从表，在删除主表。*/### 列级约束 和表级约束的修改alter table stuinfo modify column seat int unique;alter table stuinfo add unique(seat);### 删除主键alter table stuinfo drop index seat; alter table stuinfo drop foreign key fk_stuinfo_major;### 标识列 auto_increment 自增长CREATE TABLE tab_identity( id INT PRIMARY KEY AUTO_INCREMENT);show VARIABLES LIKE &apos;%auto_increment%&apos;;SET AUTO_INCREMENT_INCREMENT =3;# 修改步长为3#标识列必须是一个 key（索引） ，只能有一个标识列，标识列必须是数字类型。 TCL 事务控制语言存储引擎是指在mysql中的数据用各种不同的技术存储在文件（内存）中，通过show engines查看引擎。mysql中的引擎有innodb,myisam,memory,只有innodb支持事务。1SHOW ENGINES ;#查看所有的数据库引擎 事务的acid属性 原子性，要么都成功要么都失败，不能再分割。 一致性，事务必须从一个一致性状态，变换到另一个一致性状态。 隔离性, 事务与并发事务之间不互相干扰。 持久性，操作一旦被提交就是永久性的。事务的创建 隐式事务：事务没有明显的开始和结束标记，比如insert、update、delete语句。 显式事务：有开启结束的标记1234567891011show variables like &apos;autocommit&apos;;#查看事务# 步骤1：开启事务set autocommit=0;start transaction;#可选的# 步骤2：编写sql。。。# 步骤3：结束事务commit;#提交rollback;#回滚SAVEPOINT 保存点;#设置保存点rollback to 保存点;#回滚到保存点 多个事务的并发问题 脏读:所谓脏读是指一个事务中访问到了另外一个事务未提交的数据，如下图：如果会话 2 更新 age 为 10，但是在 commit 之前，会话 1 希望得到 age，那么会获得的值就是更新前的值。或者如果会话 2 更新了值但是执行了 rollback，而会话 1 拿到的仍是 10。这就是脏读。 幻读：一个事务读取2次，得到的记录条数不一致上图很明显的表示了这个情况，由于在会话 1 之间插入了一个新的值，所以得到的两次数据就不一样了。 不可重复读：一个事务读取同一条记录2次，得到的结果不一致：由于在读取中间变更了数据，所以会话 1 事务查询期间的得到的结果就不一样了。 幻读和不可重复读的区别在于：幻读读取的是范围，此时会话2一般是插入语句。不可重复读读取的是一条数据，此时会话2一般是修改这条语句。 通过事务的隔离级别解决问题1234567891011select @@tx_isolation;#查看隔离级别/* 脏读 不可重复读 幻读 1.read uncommitted: 是 是 是 2.read committed 否 是 是 3.repeatable read 否 否 是 4.serializable 否 否 否 mysql 默认 repeatable read oracle 默认 read committed 设置隔离级别 set session|global transaction isolation level 隔离级别 */ 视图 通过表动态生成的数据，虚拟的表，只保存sql逻辑，不保存查询结果 应用场景多个地方使用到同样的查询结果，该查询结果sql比较复杂123456CREATE VIEW 视图名 AS SELECT * FROM user where id&gt;3;#创建视图alter VIEW 视图名 AS SELECT * FROM user where id&gt;4;#创建修改select * from 视图名;#使用视图DROP VIEW 视图名;#删除视图DESC 视图名;#查看视图SHOW CREATE VIEW 视图名;#查看视图创建过程 变量 系统变量：全局变量，会话变量。自定义变量：用户变量，局部变量 系统变量123456789# 1.查看所有系统变量# SHOW GLOBAL|session variables# 2.查看满足条件的部分系统变量# show global|session variables like &apos;%char%&apos;# 3.查看指定的某个系统变量的值# select @@global|session.系统变量名;# 4.为某个系统变量赋值# set global|session 系统变量名 = 值 # 或者 set @@global|session.系统变量名=值; 自定义变量1234567# 声明并初始化## set @用户变量名=值## 或者 set @用户变量名:=值## 或者 select count(*) into 变量名 from emplooyees;# 查看变量## select @变量名; 局部变量12345678# 声明## declare 变量名 类型; ## declare 变量名 类型 default 值# 赋值## set @变量名=值## 或者 set @变量名:=值## 或者 select count(*) into 变量名 from employees;]]></content>
      <categories>
        <category>it</category>
      </categories>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[我的第一篇博客]]></title>
    <url>%2F2018%2F08%2F06%2F%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2%2F</url>
    <content type="text"><![CDATA[hello world !this is my first blog 没有其他内容了。。。]]></content>
      <categories>
        <category>life</category>
      </categories>
      <tags>
        <tag>life</tag>
      </tags>
  </entry>
</search>
